(function(){
const __modules = {
'src/core/ui/template.js': (module, exports, __require) => {
// Generated from src/core/ui/template.html
const templateHtml = `<div class="valki-root" id="valki-root">

  <!-- Floating Bubble Launcher -->
  <button id="valki-bubble" class="valki-bubble" type="button" aria-label="Open Valki chat">
    <span class="valki-bubble-ping" id="valki-bubble-ping" aria-hidden="true" style="display:none;"></span>

    <svg class="valki-bubble-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path
        d="M21 12c0 4.418-4.03 8-9 8a11.1 11.1 0 0 1-3.86-.68L3 20l1.54-3.08A7.3 7.3 0 0 1 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8Z"
        stroke="currentColor"
        stroke-width="2.2"
        stroke-linejoin="round">
      </path>

      <path
        d="M7.5 12h.01M12 12h.01M16.5 12h.01"
        stroke="currentColor"
        stroke-width="2.8"
        stroke-linecap="round">
      </path>
    </svg>

    <span class="valki-bubble-badge" id="valki-bubble-badge" aria-hidden="true" style="display:none;">1</span>
  </button>

  <!-- Chat overlay -->
  <div id="valki-overlay" class="valki-overlay" aria-hidden="true">
    <div class="valki-modal" role="dialog" aria-modal="true" aria-labelledby="valki-title">

      <!-- Header -->
      <div class="valki-modal-header">
        <div class="valki-modal-header-inner">

          <div class="valki-header-left">
            <img class="valki-header-avatar" id="valki-header-avatar"
                 src="https://valki.wiki/blogmedia/Valki%20Talki.jpg"
                 alt="Valki avatar" />
            <div class="valki-modal-title-text">
              <span class="name" id="valki-title">Valki Talki</span>
              <span class="session" id="valki-session-label">Guest ðŸŸ </span>
            </div>
          </div>

          <div class="valki-header-actions">
            <button class="valki-pill primary" id="valki-loginout-btn" type="button" title="Login">Login</button>
            <button class="valki-pill" id="valki-deleteall-btn" type="button" title="Delete all messages">Delete</button>
            <button id="valki-close" class="valki-close-btn" type="button" aria-label="Close chat">âœ•</button>
          </div>

        </div>
      </div>

      <!-- Messages -->
      <div id="valki-messages" class="valki-messages" role="log" aria-live="polite">
        <div class="valki-messages-inner" id="valki-messages-inner"></div>
      </div>

      <!-- Composer -->
      <form id="valki-chat-form" class="valki-chat-form" autocomplete="off">
        <div class="valki-chat-form-inner">

          <div class="valki-chat-inner">
            <button class="valki-chat-attach" id="valki-chat-attach" type="button" aria-label="Upload image">
              <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.9-9.9a4 4 0 015.66 5.66l-9.9 9.9a2 2 0 01-2.83-2.83l9.19-9.19"></path>
              </svg>
            </button>

            <input id="valki-file-input" type="file" accept="image/jpeg,image/png" multiple style="display:none" />

            <textarea id="valki-chat-input" class="valki-chat-input" rows="1"
                      placeholder=""
                      aria-label="Message Valki"
                      enterkeyhint="send"></textarea>

            <button class="valki-chat-send" id="valki-chat-send" type="submit" aria-label="Send message">
              <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M12 19V5"></path>
                <path d="M5 12l7-7 7 7"></path>
              </svg>
            </button>
          </div>

          <div class="valki-attachments" id="valki-attachments" aria-label="Attachments" style="display:none;"></div>

          <div class="valki-disclaimer">
            <div>Valki signals may distort. Verify info.</div>
            <button type="button" class="valki-disclaimer-button"
                    onclick="if (typeof displayPreferenceModal === 'function') { displayPreferenceModal(); }">
              See cookie preferences.
            </button>
          </div>

        </div>
      </form>

    </div>
  </div>

  <!-- Auth / Login overlay -->
  <div id="valki-auth-overlay" class="valki-auth-overlay" aria-hidden="true">
    <div class="valki-auth-modal" role="dialog" aria-modal="true" aria-label="Login required">
      <div class="valki-auth-header">
        <img src="https://valki.wiki/blogmedia/Valki%20Talki.jpg" class="valki-auth-avatar" alt="Valki avatar" />
      </div>
      <h2 class="valki-auth-title" id="valki-auth-title">Log in to continue</h2>
      <p class="valki-auth-subtitle" id="valki-auth-subtitle">Sign in to keep your chat history and manage messages.</p>

      <div class="valki-auth-buttons">
        <button type="button" class="valki-auth-btn primary" id="valki-login-discord-btn">
          <span aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
              <path d="M20.3 4.7a19.6 19.6 0 0 0-4.9-1.5l-.2.3c1.8.5 2.6 1.2 2.6 1.2a16.4 16.4 0 0 0-5.8-1.8 16.4 16.4 0 0 0-5.8 1.8s.8-.7 2.6-1.2l-.2-.3A19.6 19.6 0 0 0 3.7 4.7C1.4 8 1 11 1 14c1.4 2.1 3.5 3.4 5.7 4 .4-.6.9-1.4 1.2-2.1-.7-.3-1.4-.6-2-.9l.5-.4c1.2.6 2.5 1 3.8 1.2a15 15 0 0 0 3.6 0c1.3-.2 2.6-.6 3.8-1.2l.5.4c-.6.3-1.3.6-2 .9.4.8.8 1.5 1.2 2.1 2.2-.6 4.3-1.9 5.7-4 0-3-.4-6-2.7-9.3ZM9 13.4c-.8 0-1.4-.7-1.4-1.6s.6-1.6 1.4-1.6 1.4.7 1.4 1.6-.6 1.4-1.4 1.6Zm6 0c-.8 0-1.4-.7-1.4-1.6s.6-1.6 1.4-1.6 1.4.7 1.4 1.6-.6 1.4-1.4 1.6Z"></path>
            </svg>
          </span>
          <span>Continue with Discord</span>
        </button>

        <button type="button" class="valki-auth-btn" id="valki-login-google-btn">
          <span aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
              <path d="M12 10.2v3.9h5.4c-.2 1.3-1.6 3.9-5.4 3.9-3.3 0-6-2.7-6-6s2.7-6 6-6c1.9 0 3.2.8 3.9 1.5l2.7-2.6C17 3.3 14.8 2.4 12 2.4 6.9 2.4 2.8 6.5 2.8 11.6S6.9 20.8 12 20.8c5.9 0 9.8-4.1 9.8-9.8 0-.7-.1-1.2-.2-1.8H12z"></path>
            </svg>
          </span>
          <span>Continue with Google</span>
        </button>

        <button type="button" class="valki-auth-btn" id="valki-join-discord-btn">Join Discord server</button>
      </div>

      <div class="valki-auth-note" id="valki-auth-note">Guest limits apply.</div>
      <div class="valki-auth-dismiss" id="valki-auth-dismiss">Not now</div>
    </div>
  </div>

  <!-- Confirm delete all -->
  <div id="valki-confirm-overlay" class="valki-confirm-overlay" aria-hidden="true">
    <div class="valki-confirm-modal" role="dialog" aria-modal="true" aria-label="Confirm delete">
      <h3 class="valki-confirm-title">Delete all messages?</h3>
      <p class="valki-confirm-sub">This will remove your chat history for this session.</p>
      <div class="valki-confirm-actions">
        <button type="button" class="valki-confirm-btn" id="valki-confirm-no"><span>No</span></button>
        <button type="button" class="valki-confirm-btn danger" id="valki-confirm-yes"><span>Yes, delete</span></button>
      </div>
    </div>
  </div>

  <!-- Confirm logout (âœ… class made consistent) -->
  <div id="valki-logout-overlay" class="valki-logout-overlay" aria-hidden="true" style="display:none;">
    <div class="valki-confirm-modal" role="dialog" aria-modal="true" aria-label="Confirm logout">
      <h3 class="valki-confirm-title">Log out?</h3>
      <p class="valki-confirm-sub">You will switch back to guest mode on this device.</p>
      <div class="valki-confirm-actions">
        <button type="button" class="valki-confirm-btn" id="valki-logout-no"><span>Cancel</span></button>
        <button type="button" class="valki-confirm-btn danger" id="valki-logout-yes"><span>Yes, log out</span></button>
      </div>
    </div>
  </div>

const templateHtml = `
</div>
`;

exports.templateHtml = templateHtml;

},
'src/core/config.js': (module, exports, __require) => {
const DEFAULT_BASE_URL = 'https://auth.valki.wiki';

const DEFAULT_CONSTANTS = {
  avatarUrl: 'https://valki.wiki/blogmedia/Valki%20Talki.jpg',
  guestFreeRoundSize: 3,
  guestMaxRounds: 2,
  chatMaxLines: 4,
  maxFiles: 4,
  maxBytes: 5 * 1024 * 1024,
  bubbleSeenKey: 'valki_bubble_seen_v1',
  authKey: 'valki_auth_token_v1',
  historyKey: 'valki_history_v20',
  guestMeterKey: 'valki_guest_meter_v1',
  clientIdKey: 'valki_client_id_v20',
  copy: {
    genericError: 'Something went wrong talking to Valki.',
    noResponse: 'â€¦krrzzztâ€¦ no response received.'
  }
};

function buildEndpoints(baseUrl) {
  const trimmed = String(baseUrl || DEFAULT_BASE_URL).replace(/\/$/, '');
  return {
    baseUrl: trimmed,
    apiValki: `${trimmed}/api/valki`,
    apiMe: `${trimmed}/api/me`,
    apiMessages: `${trimmed}/api/messages`,
    apiClear: `${trimmed}/api/clear`,
    apiImportGuest: `${trimmed}/api/import-guest`,
    authDiscord: `${trimmed}/auth/discord`,
    authGoogle: `${trimmed}/auth/google`,
    discordInvite: 'https://discord.com/invite/vqDJuGJN2u'
  };
}

function buildConfig(overrides = {}) {
  const baseUrl = overrides.baseUrl || DEFAULT_BASE_URL;
  const endpoints = buildEndpoints(baseUrl);

  return {
    ...DEFAULT_CONSTANTS,
    ...overrides,
    ...endpoints,
    theme: overrides.theme || 'vichat'
  };
}

exports.DEFAULT_BASE_URL = DEFAULT_BASE_URL;
exports.DEFAULT_CONSTANTS = DEFAULT_CONSTANTS;
exports.buildConfig = buildConfig;

},
'src/core/storage.js': (module, exports, __require) => {
const { DEFAULT_CONSTANTS } = __require('src/core/config.js');

function cleanText(value) {
  return String(value ?? '').replace(/\u0000/g, '').trim();
}

function safeJsonParse(raw, fallback) {
  if (typeof raw !== 'string' || !raw) return fallback;
  try {
    return JSON.parse(raw);
  } catch {
    return fallback;
  }
}

function parsePx(value) {
  const num = parseFloat(String(value ?? '').replace('px', ''));
  return Number.isFinite(num) ? num : 0;
}

function readLocalStorage(key) {
  try {
    return localStorage.getItem(key);
  } catch {
    return null;
  }
}

function writeLocalStorage(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch {
    /* no-op */
  }
}

function removeLocalStorage(key) {
  try {
    localStorage.removeItem(key);
  } catch {
    /* no-op */
  }
}

function getAuthToken(config = DEFAULT_CONSTANTS) {
  return readLocalStorage(config.authKey) || '';
}

function setAuthToken(token, config = DEFAULT_CONSTANTS) {
  writeLocalStorage(config.authKey, String(token || ''));
}

function clearAuthToken(config = DEFAULT_CONSTANTS) {
  removeLocalStorage(config.authKey);
}

function loadGuestHistory(config = DEFAULT_CONSTANTS) {
  const raw = readLocalStorage(config.historyKey);
  const arr = safeJsonParse(raw, []);
  if (!Array.isArray(arr)) return [];
  return arr.filter(
    (item) => item && (item.type === 'user' || item.type === 'bot') && typeof item.text === 'string'
  );
}

function saveGuestHistory(arr, config = DEFAULT_CONSTANTS) {
  writeLocalStorage(config.historyKey, JSON.stringify(arr || []));
}

function clearGuestHistory(config = DEFAULT_CONSTANTS) {
  removeLocalStorage(config.historyKey);
}

function getGuestMeter(config = DEFAULT_CONSTANTS) {
  const raw = readLocalStorage(config.guestMeterKey);
  const meter = safeJsonParse(raw, null) || { count: 0, roundsShown: 0 };
  meter.count = Number.isFinite(Number(meter.count)) ? Number(meter.count) : 0;
  meter.roundsShown = Number.isFinite(Number(meter.roundsShown)) ? Number(meter.roundsShown) : 0;
  return meter;
}

function setGuestMeter(meter, config = DEFAULT_CONSTANTS) {
  writeLocalStorage(config.guestMeterKey, JSON.stringify(meter));
}

function resetGuestMeter(config = DEFAULT_CONSTANTS) {
  removeLocalStorage(config.guestMeterKey);
}

function shouldShowBubbleBadge(config = DEFAULT_CONSTANTS) {
  const seen = readLocalStorage(config.bubbleSeenKey);
  return seen !== '1';
}

function markBubbleSeen(config = DEFAULT_CONSTANTS) {
  writeLocalStorage(config.bubbleSeenKey, '1');
}

function getOrCreateClientId(config = DEFAULT_CONSTANTS) {
  const existing = readLocalStorage(config.clientIdKey);
  if (existing && typeof existing === 'string') return existing;
  const id = generateId('valk-client');
  writeLocalStorage(config.clientIdKey, id);
  return id;
}

function generateId(prefix = 'id') {
  const p = String(prefix || 'id');
  try {
    const cryptoObj = window.crypto;
    if (cryptoObj && typeof cryptoObj.getRandomValues === 'function') {
      const arr = new Uint32Array(2);
      cryptoObj.getRandomValues(arr);
      const hex = Array.from(arr, (n) => n.toString(16).padStart(8, '0')).join('');
      return `${p}-${hex}`;
    }
  } catch {
    /* ignore */
  }
  return `${p}-${Math.random().toString(16).slice(2)}${Date.now().toString(16)}`;
}

exports.cleanText = cleanText;
exports.safeJsonParse = safeJsonParse;
exports.parsePx = parsePx;
exports.getAuthToken = getAuthToken;
exports.setAuthToken = setAuthToken;
exports.clearAuthToken = clearAuthToken;
exports.loadGuestHistory = loadGuestHistory;
exports.saveGuestHistory = saveGuestHistory;
exports.clearGuestHistory = clearGuestHistory;
exports.getGuestMeter = getGuestMeter;
exports.setGuestMeter = setGuestMeter;
exports.resetGuestMeter = resetGuestMeter;
exports.shouldShowBubbleBadge = shouldShowBubbleBadge;
exports.markBubbleSeen = markBubbleSeen;
exports.getOrCreateClientId = getOrCreateClientId;
exports.generateId = generateId;

},
'src/core/attachments.js': (module, exports, __require) => {
const { generateId } = __require('src/core/storage.js');

function createAttachmentController({
  attachTray,
  attachButton,
  fileInput,
  clampComposer,
  updateComposerHeight,
  config
}) {
  let attachments = [];

  function showAttachTray() {
    if (!attachTray) return;
    if (!attachments || attachments.length === 0) {
      attachTray.style.display = 'none';
      attachTray.innerHTML = '';
      updateComposerHeight?.();
      return;
    }

    attachTray.style.display = 'flex';
    attachTray.innerHTML = '';

    for (const attachment of attachments) {
      const wrap = document.createElement('div');
      wrap.className = 'valki-attachment';

      const img = document.createElement('img');
      img.src = attachment.dataUrl;
      img.alt = attachment.name || 'attachment';
      img.loading = 'lazy';

      const remove = document.createElement('button');
      remove.type = 'button';
      remove.className = 'valki-attachment-remove';
      remove.textContent = 'Ã—';
      remove.setAttribute('aria-label', 'Remove attachment');

      remove.addEventListener('click', () => {
        attachments = attachments.filter((item) => item.id !== attachment.id);
        showAttachTray();
        clampComposer?.();
        updateComposerHeight?.();
      });

      wrap.appendChild(img);
      wrap.appendChild(remove);
      attachTray.appendChild(wrap);
    }

    updateComposerHeight?.();
  }

  function setDisabled(on, parentDisabled = false) {
    const disabled = !!on || !!parentDisabled;
    if (!attachButton) return;
    attachButton.disabled = disabled;
    attachButton.style.opacity = disabled ? '.55' : '';
  }

  function clearAttachments() {
    attachments = [];
    showAttachTray();
  }

  function snapshot() {
    return (attachments || []).map((att) => ({
      name: att?.name || 'image',
      type: att?.type || 'image/jpeg',
      dataUrl: att?.dataUrl || ''
    }));
  }

  function readFileAsDataURL(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(String(reader.result || ''));
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  async function addFiles(fileList) {
    const files = Array.from(fileList || []);
    for (const file of files) {
      if (attachments.length >= config.maxFiles) break;
      const type = String(file.type || '');
      const ok = type === 'image/jpeg' || type === 'image/png';
      if (!ok) continue;
      if (file.size > config.maxBytes) continue;

      const dataUrl = await readFileAsDataURL(file).catch(() => '');
      if (!dataUrl) continue;

      attachments.push({
        id: generateId('att'),
        name: file.name || 'image',
        type,
        dataUrl
      });
    }
    showAttachTray();
  }

  return {
    setDisabled,
    addFiles,
    clearAttachments,
    showAttachTray,
    snapshot
  };
}

exports.createAttachmentController = createAttachmentController;

},
'src/core/guestMeter.js': (module, exports, __require) => {
const { getGuestMeter, setGuestMeter, resetGuestMeter } = __require('src/core/storage.js');

function createGuestMeter({ config, isLoggedIn }) {
  function guestHardBlocked() {
    if (isLoggedIn()) return false;
    const meter = getGuestMeter(config);
    return meter.count >= config.guestFreeRoundSize * config.guestMaxRounds;
  }

  function bumpGuestCount() {
    if (isLoggedIn()) return;
    const meter = getGuestMeter(config);
    meter.count += 1;
    setGuestMeter(meter, config);
  }

  function maybePromptLoginAfterSend(openAuth) {
    if (isLoggedIn()) return;
    const meter = getGuestMeter(config);
    const threshold = (meter.roundsShown + 1) * config.guestFreeRoundSize;
    if (meter.count >= threshold && meter.roundsShown < config.guestMaxRounds) {
      meter.roundsShown += 1;
      setGuestMeter(meter, config);
      openAuth?.({ hard: meter.roundsShown >= config.guestMaxRounds });
    }
  }

  return {
    guestHardBlocked,
    bumpGuestCount,
    maybePromptLoginAfterSend,
    reset: () => resetGuestMeter(config)
  };
}

exports.createGuestMeter = createGuestMeter;

},
'src/core/markdown.js': (module, exports, __require) => {
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const el = document.createElement('script');
    el.src = src;
    el.onload = resolve;
    el.onerror = reject;
    document.head.appendChild(el);
  });
}

let markdownReady = false;
let markdownLoading = null;

export async function ensureMarkdownLibs() {
  if (markdownReady) return;
  if (markdownLoading) return markdownLoading;
  markdownLoading = (async () => {
    await loadScript('https://cdn.jsdelivr.net/npm/marked/marked.min.js');
    await loadScript('https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js');
    markdownReady = true;
  })();
  return markdownLoading;
}

function renderMarkdown(text) {
  if (!text) return '';
  if (window.marked) {
    let html = window.marked.parse(text, { breaks: true });
    if (window.DOMPurify) html = window.DOMPurify.sanitize(html);
    return html;
  }
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\n/g, '<br>');
}

function hardenLinks(containerEl) {
  if (!containerEl) return;
  containerEl.querySelectorAll('a').forEach((a) => {
    const href = (a.getAttribute('href') || '').trim();
    if (/^javascript:/i.test(href)) a.removeAttribute('href');
    a.setAttribute('target', '_blank');
    a.setAttribute('rel', 'noopener noreferrer');
  });
}

exports.renderMarkdown = renderMarkdown;
exports.hardenLinks = hardenLinks;

},
'src/core/ui/messages.js': (module, exports, __require) => {
const { ensureMarkdownLibs, hardenLinks, renderMarkdown } = __require('src/core/markdown.js');

function isNearBottom(el, thresholdPx = 90) {
  if (!el) return true;
  const remaining = el.scrollHeight - el.scrollTop - el.clientHeight;
  return remaining < thresholdPx;
}

function createMessageController({
  messagesEl,
  messagesInner,
  avatarUrl,
  updateDeleteButtonVisibility
}) {
  function scrollToBottom(force = false) {
    if (!messagesEl) return;
    if (force || isNearBottom(messagesEl)) {
      messagesEl.scrollTop = messagesEl.scrollHeight + 10000;
    }
  }

  async function addMessage({ type, text }) {
    const stick = isNearBottom(messagesEl);
    if (type === 'bot') await ensureMarkdownLibs();
    messagesInner.appendChild(createMessageRow({ type, text }));
    scrollToBottom(stick);
    updateDeleteButtonVisibility?.();
  }

  function createMessageRow({ type, text }) {
    const row = document.createElement('div');
    row.className = `valki-msg-row ${type === 'user' ? 'user' : 'bot'}`;

    if (type === 'bot') {
      const avatarWrap = document.createElement('div');
      avatarWrap.className = 'valki-bot-avatar-wrap';
      const avatar = document.createElement('img');
      avatar.className = 'valki-bot-avatar';
      avatar.src = avatarUrl;
      avatar.alt = 'Valki icon';
      avatarWrap.appendChild(avatar);
      row.appendChild(avatarWrap);
    }

    const bubble = document.createElement('div');
    bubble.className = 'valki-msg-bubble';

    if (type === 'bot') {
      bubble.innerHTML = renderMarkdown(text);
      hardenLinks(bubble);
    } else {
      bubble.textContent = text;
    }

    row.appendChild(bubble);
    return row;
  }

  function clearMessagesUI() {
    messagesInner.innerHTML = '';
    updateDeleteButtonVisibility?.();
  }

  function createTypingRow() {
    const typingRow = document.createElement('div');
    typingRow.className = 'valki-msg-row bot';

    const avatarWrap = document.createElement('div');
    avatarWrap.className = 'valki-bot-avatar-wrap';
    const avatar = document.createElement('img');
    avatar.className = 'valki-bot-avatar';
    avatar.src = avatarUrl;
    avatar.alt = 'Valki icon';
    avatarWrap.appendChild(avatar);
    typingRow.appendChild(avatarWrap);

    const bubbleEl = document.createElement('div');
    bubbleEl.className = 'valki-msg-bubble';
    bubbleEl.innerHTML = `
    <div class="valki-typing-bar">
      <span class="valki-typing-dots"><span></span><span></span><span></span></span>
      <span class="valki-typing-label">Analyzing the signalâ€¦</span>
    </div>`;
    typingRow.appendChild(bubbleEl);

    const stick = isNearBottom(messagesEl);
    messagesInner.appendChild(typingRow);
    scrollToBottom(stick);

    return typingRow;
  }

  function hasAnyRealMessages() {
    const rows = messagesInner.querySelectorAll('.valki-msg-row');
    for (const row of rows) {
      if (row.querySelector('.valki-typing-bar')) continue;
      return true;
    }
    return false;
  }

  function scrollToBottomHard() {
    if (!messagesEl) return;
    requestAnimationFrame(() => {
      messagesEl.scrollTop = messagesEl.scrollHeight + 10000;
      requestAnimationFrame(() => {
        messagesEl.scrollTop = messagesEl.scrollHeight + 10000;
      });
    });
  }

  return {
    addMessage,
    clearMessagesUI,
    createTypingRow,
    hasAnyRealMessages,
    scrollToBottom,
    scrollToBottomHard
  };
}

exports.createMessageController = createMessageController;

},
'src/core/ui/composer.js': (module, exports, __require) => {
const { parsePx } = __require('src/core/storage.js');

const searchCopy = {
  en: 'What went wrong?',
  nl: 'Wat ging er mis?',
  de: 'Was ist schiefgelaufen?',
  fr: 'Quâ€™est-ce qui sâ€™est mal passÃ© ?',
  es: 'Â¿QuÃ© saliÃ³ mal?',
  it: 'Cosa Ã¨ andato storto?',
  pt: 'O que deu errado?',
  pl: 'Co poszÅ‚o nie tak?',
  ja: 'ä½•ãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸï¼Ÿ',
  zh: 'å“ªé‡Œå‡ºäº†é—®é¢˜ï¼Ÿ',
  ko: 'ë¬´ì—‡ì´ ìž˜ëª»ëë‚˜ìš”?',
  ar: 'Ù…Ø§ Ø§Ù„Ø°ÙŠ Ø­Ø¯Ø« Ø®Ø·Ø£ØŸ',
  tr: 'Ne yanlÄ±ÅŸ gitti?'
};

function computeLineHeightPx(el) {
  const cs = getComputedStyle(el);
  const fontSize = parsePx(cs.fontSize) || 16;
  const lh = cs.lineHeight;
  if (!lh || lh === 'normal') return Math.round(fontSize * 1.35);
  if (String(lh).endsWith('px')) return Math.round(parsePx(lh));
  const asNum = parseFloat(lh);
  if (Number.isFinite(asNum)) return Math.round(fontSize * asNum);
  return Math.round(fontSize * 1.35);
}

function createComposerController({ chatInput, chatForm, config, updateComposerHeight }) {
  function clampComposer() {
    if (!chatInput) return;
    chatInput.style.height = 'auto';
    const cs = getComputedStyle(chatInput);
    const lh = computeLineHeightPx(chatInput);
    const padTop = parsePx(cs.paddingTop);
    const padBot = parsePx(cs.paddingBottom);
    const maxH = Math.ceil(lh * config.chatMaxLines + padTop + padBot);
    const scrollH = chatInput.scrollHeight;
    const next = Math.min(scrollH, maxH);
    chatInput.style.height = `${next}px`;
    chatInput.style.overflowY = scrollH > maxH ? 'auto' : 'hidden';
    updateComposerHeight?.();
  }

  function pickLocale() {
    const langs = navigator.languages && navigator.languages.length ? navigator.languages : [navigator.language || 'en'];
    for (const l of langs) {
      const lang = String(l).toLowerCase();
      const base = lang.split('-')[0];
      if (searchCopy[lang]) return lang;
      if (searchCopy[base]) return base;
    }
    return 'en';
  }

  function applyPlaceholders() {
    if (!chatInput) return;
    const loc = pickLocale();
    const txt = searchCopy[loc] || searchCopy.en;
    chatInput.placeholder = txt;
  }

  if (chatForm && typeof ResizeObserver !== 'undefined') {
    try {
      const ro = new ResizeObserver(() => updateComposerHeight?.());
      ro.observe(chatForm);
    } catch {
      /* ignore */
    }
  }

  return { clampComposer, applyPlaceholders };
}

exports.createComposerController = createComposerController;

},
'src/core/ui/overlay.js': (module, exports, __require) => {
let lockState = null;

function setVisible(el, on) {
  if (!el) return;
  const show = !!on;
  el.style.display = show ? 'flex' : 'none';
  el.setAttribute('aria-hidden', show ? 'false' : 'true');
  if (show) {
    requestAnimationFrame(() => el.classList.add('is-visible'));
  } else {
    el.classList.remove('is-visible');
  }
}

function lockBodyScroll() {
  const y = window.scrollY || 0;
  const body = document.body;
  lockState = {
    position: body.style.position,
    top: body.style.top,
    left: body.style.left,
    right: body.style.right,
    width: body.style.width,
    overflow: body.style.overflow,
    touchAction: body.style.touchAction,
    scrollY: y
  };
  body.dataset.valkiScrollY = String(y);
  body.style.position = 'fixed';
  body.style.top = `-${y}px`;
  body.style.left = '0';
  body.style.right = '0';
  body.style.width = '100%';
  body.style.overflow = 'hidden';
  body.style.touchAction = 'none';
  document.documentElement.classList.add('valki-chat-open');
}

function unlockBodyScroll() {
  const body = document.body;
  const state = lockState;
  body.style.position = state?.position || '';
  body.style.top = state?.top || '';
  body.style.left = state?.left || '';
  body.style.right = state?.right || '';
  body.style.width = state?.width || '';
  body.style.overflow = state?.overflow || '';
  body.style.touchAction = state?.touchAction || '';
  document.documentElement.classList.remove('valki-chat-open');
  const y = parseInt(body.dataset.valkiScrollY || '0', 10);
  delete body.dataset.valkiScrollY;
  window.scrollTo({ top: y, behavior: 'auto' });
  lockState = null;
}

function createOverlayController({ overlay, chatInput, updateComposerHeight, clampComposer, scrollToBottom }) {
  function isChatOpen() {
    return overlay?.classList.contains('is-visible');
  }

  function openOverlay() {
    if (!overlay) return;
    setVisible(overlay, true);
    lockBodyScroll();
    setTimeout(() => {
      updateComposerHeight?.();
      scrollToBottom?.(true);
      try {
        chatInput?.focus({ preventScroll: true });
      } catch {
        chatInput?.focus();
      }
      clampComposer?.();
      updateComposerHeight?.();
    }, 60);
  }

  function closeOverlay() {
    if (!overlay) return;
    overlay.classList.remove('is-visible');
    setTimeout(() => {
      setVisible(overlay, false);
      unlockBodyScroll();
    }, 220);
  }

  return { isChatOpen, openOverlay, closeOverlay };
}

exports.setVisible = setVisible;
exports.createOverlayController = createOverlayController;

},
'src/core/auth.js': (module, exports, __require) => {
function createAuthController({ config, onToken }) {
  const backendOrigin = new URL(config.baseUrl).origin;

  function handleMessage(event) {
    if (event.origin !== backendOrigin) return;
    const data = event.data;
    if (!data || typeof data !== 'object') return;
    if (data.type !== 'valki_auth' || !data.token) return;
    onToken?.(String(data.token || ''));
  }

  function attach() {
    window.addEventListener('message', handleMessage);
  }

  function detach() {
    window.removeEventListener('message', handleMessage);
  }

  function openOAuthPopup(authStartUrl, popupName) {
    const returnTo = window.location.origin;
    const w = 480;
    const h = 720;
    const y = Math.max(0, (window.screenY || 0) + (window.outerHeight - h) / 2);
    const x = Math.max(0, (window.screenX || 0) + (window.outerWidth - w) / 2);
    const url = `${authStartUrl}?returnTo=${encodeURIComponent(returnTo)}`;

    const popup = window.open(
      url,
      popupName,
      `popup=yes,width=${w},height=${h},left=${Math.round(x)},top=${Math.round(y)}`
    );

    if (!popup) {
      window.location.href = url;
      return;
    }
    try {
      popup.focus();
    } catch {
      /* ignore */
    }
  }

  return {
    attach,
    detach,
    openDiscordLogin: () => openOAuthPopup(config.authDiscord, 'valki_discord_login'),
    openGoogleLogin: () => openOAuthPopup(config.authGoogle, 'valki_google_login'),
    openDiscordInvite: () => window.open(config.discordInvite, '_blank', 'noopener,noreferrer')
  };
}

exports.createAuthController = createAuthController;

},
'src/core/api.js': (module, exports, __require) => {
export async function fetchMe({ token, config }) {
  if (!token) return null;
  try {
    const res = await fetch(config.apiMe, { headers: { Authorization: `Bearer ${token}` } });
    const data = await res.json().catch(() => null);
    if (data && data.loggedIn && data.user) return data.user;
  } catch {
    /* ignore */
  }
  return null;
}

export async function fetchMessages({ token, config }) {
  if (!token) return { ok: false, messages: [] };
  try {
    const res = await fetch(config.apiMessages, { headers: { Authorization: `Bearer ${token}` } });
    if (!res.ok) return { ok: false, messages: [] };
    const data = await res.json().catch(() => null);
    if (!data || !Array.isArray(data.messages)) return { ok: true, messages: [] };
    return {
      ok: true,
      messages: data.messages.map((m) => ({
        role: m.role === 'assistant' ? 'bot' : 'user',
        text: String(m.content || '')
      }))
    };
  } catch {
    return { ok: false, messages: [] };
  }
}

export async function clearMessages({ token, config }) {
  if (!token) return false;
  try {
    const res = await fetch(config.apiClear, { method: 'POST', headers: { Authorization: `Bearer ${token}` } });
    return res.ok;
  } catch {
    return false;
  }
}

export async function importGuestMessages({ token, guestHistory, config }) {
  if (!token || !Array.isArray(guestHistory) || !guestHistory.length) return;
  const payload = {
    messages: guestHistory.slice(-80).map((m) => ({
      role: m.type === 'bot' ? 'assistant' : 'user',
      content: String(m.text || '')
    }))
  };

  try {
    await fetch(config.apiImportGuest, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
      body: JSON.stringify(payload)
    });
  } catch {
    /* non-fatal */
  }
}

export async function askValki({ message, clientId, images, token, config }) {
  const payload = { message, clientId, images };
  const headers = { 'Content-Type': 'application/json' };
  if (token) headers.Authorization = `Bearer ${token}`;

  try {
    const res = await fetch(config.apiValki, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      let errMsg = config.copy.genericError;
      const ct = (res.headers.get('content-type') || '').toLowerCase();
      if (ct.includes('application/json')) {
        const json = await res.json().catch(() => null);
        if (json && typeof json.error === 'string') {
          errMsg = `ksshhâ€¦ ${json.error}`;
        }
      }
      return { ok: false, message: errMsg };
    }

    const data = await res.json().catch(() => null);
    const reply =
      data && typeof data.reply === 'string' && data.reply.trim()
        ? String(data.reply)
        : config.copy.noResponse;

    return { ok: true, message: reply };
  } catch {
    return { ok: false, message: config.copy.genericError };
  }
}

},
'src/themes/shared.js': (module, exports, __require) => {
// Generated from src/themes/shared.css
const sharedCss = `/* =========================================================
   VALKI â€” Theme + Layout Locks
========================================================= */
#valki-root{
  /* Theme */
  --bg: #0b0b0b;
  --surface: rgba(255,255,255,.04);
  --surface-2: rgba(255,255,255,.06);
  --border: rgba(255,255,255,.10);
  --border-2: rgba(255,255,255,.16);
  --text: rgba(255,255,255,.92);
  --muted: rgba(255,255,255,.60);
  --muted-2: rgba(255,255,255,.45);

  --brand: #f15a24;
  --brand-2: #ff7a45;
  --ring: rgba(241,90,36,.22);

  --btn-fill: #e7e7e7;
  --btn-text: #0b0b0b;

  /* HARD layout lock (ChatGPT feel) */
  --col: 760px;
  --gutter: 24px;

  --radius: 14px;
  --radius-pill: 999px;

  --shadow-1: 0 12px 40px rgba(0,0,0,.55);
  --shadow-2: 0 20px 70px rgba(0,0,0,.70);

  --font: system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text",Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;

  --valki-vh: 1vh;
  --vvh: calc(var(--valki-vh, 1vh) * 100);

  /* (Fallback) composer height â€“ als je later JS toevoegt kan dit dynamisch */
  --composer-h: 110px;

  --valki-chat-pad-bottom: calc(env(safe-area-inset-bottom) + 10px);

  /* Background + vignette + blur */
  --chat-bg-image: url("https://valki.wiki/onewebmedia/20250814_1313_Eagle%20in%20Amsterdam_remix_01k2m4cnjnf508h5mxsej89c1m.png");
  --chat-bg-color: #070707;

  --vignette-strength: .58;  /* iets steviger voor blok-contrast */
  --side-blur: 30px;
  --side-tint: rgba(0,0,0,.18); /* transparanter zodat bg sterker doorkomt */

  /* Chat block */
  --chat-block-bg: rgba(8,8,8,.78);           /* â€œmassief blokâ€ */
  --chat-block-border: rgba(255,255,255,.10);
  --chat-block-blur: 10px;
}

#valki-root, #valki-root *{ box-sizing:border-box; }

#valki-root button,
#valki-root input,
#valki-root textarea{
  all: unset;
  box-sizing:border-box;
  font: inherit;
  color: inherit;
}

#valki-root button{ cursor:pointer; }
#valki-root input, #valki-root textarea{ cursor:text; }

/* Focus ring alleen voor knoppen (keyboard users) */
#valki-root button:focus-visible{
  outline: 1px solid var(--brand);
  outline-offset: 1px;
}

/* Geen oranje outline op input/textarea */
#valki-root input:focus-visible,
#valki-root textarea:focus-visible{
  outline: none !important;
}

#valki-root ::selection{ background: rgba(140,170,255,.14); }
#valki-root ::-moz-selection{ background: rgba(140,170,255,.14); }

@supports (-webkit-touch-callout: none){
  #valki-root input, #valki-root textarea{ font-size:16px; }
}

/* Hide background when modal is open to avoid double-blur look */
html.valki-chat-open #valki-root #valki-bg{
  display:none !important;
}

/* =========================================================
   Root container
========================================================= */
#valki-root{
  position:relative;
  z-index:1;
  min-height:var(--vvh);
  width:100%;
  margin:0;
  padding: env(safe-area-inset-top) 0 0;
  background: transparent;
  color: var(--text);
  font-family: var(--font);
}

/* =========================================================
   Floating Chat Bubble Launcher (Beautiful)
========================================================= */
#valki-root .valki-bubble{
  position: fixed;
  right: 18px;
  bottom: calc(18px + env(safe-area-inset-bottom));
  width: 64px;
  height: 64px;
  border-radius: 999px;

  /* Subtle gradient + inner ring */
  background:
    radial-gradient(140% 140% at 30% 25%, rgba(255,255,255,.28), rgba(255,255,255,0) 45%),
    linear-gradient(145deg, var(--brand-2), var(--brand));
  box-shadow:
    0 26px 70px rgba(0,0,0,.62),
    0 0 0 1px rgba(255,255,255,.18) inset,
    0 8px 24px rgba(241,90,36,.22);

  display:flex;
  align-items:center;
  justify-content:center;

  z-index: 2147482998;
  transform: translateZ(0);
  transition: transform .16s ease, box-shadow .16s ease, filter .16s ease;
}

#valki-root .valki-bubble:hover{
  transform: translateY(-2px);
  filter: brightness(1.04);
  box-shadow:
    0 30px 85px rgba(0,0,0,.68),
    0 0 0 1px rgba(255,255,255,.22) inset,
    0 10px 32px rgba(241,90,36,.26);
}

#valki-root .valki-bubble:active{
  transform: translateY(0px) scale(.99);
}

#valki-root .valki-bubble-icon{
  width: 28px;
  height: 28px;
  color: rgba(255,255,255,.96);
  filter: drop-shadow(0 8px 12px rgba(0,0,0,.35));
}

#valki-root .valki-bubble-badge{
  position:absolute;
  top: 10px;
  right: 10px;
  min-width: 18px;
  height: 18px;
  padding: 0 5px;
  border-radius: 999px;
  background: #ff3b30;
  color: #fff;
  font-size: 11px;
  font-weight: 800;
  letter-spacing: -.02em;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow: 0 14px 26px rgba(0,0,0,.55);
  border: 1px solid rgba(255,255,255,.22);
}

#valki-root .valki-bubble-ping{
  position:absolute;
  inset: -6px;
  border-radius: 999px;
  border: 2px solid rgba(241,90,36,.35);
  animation: valkiPing 2.2s infinite;
  pointer-events:none;
  opacity:.8;
}

@keyframes valkiPing{
  0%{ transform: scale(.90); opacity:.45; }
  65%{ transform: scale(1.10); opacity:0; }
  100%{ transform: scale(1.10); opacity:0; }
}

/* Hide bubble while chat is open */
html.valki-chat-open #valki-root .valki-bubble{
  opacity: 0;
  pointer-events:none;
  transform: translateY(10px);
}

/* =========================================================
   Overlays / Fullscreen chat (iOS/rotate/keyboard-proof)
   - Uses your JS-driven --vvh (via --valki-vh)
========================================================= */

/* Make sure the actual overlay nodes sit above everything */
#valki-root #valki-overlay,
#valki-root #valki-auth-overlay,
#valki-root #valki-confirm-overlay,
#valki-root #valki-logout-overlay{
  z-index: 2147483000 !important;
}

/* Base overlay layout */
#valki-root .valki-overlay,
#valki-root .valki-auth-overlay,
#valki-root .valki-confirm-overlay,
#valki-root .valki-logout-overlay{
  position: fixed;
  inset: 0;

  /* IMPORTANT: var(--vvh) = calc(var(--valki-vh) * 100) */
  height: var(--vvh);
  width: 100%;

  /* default hidden state */
  display: none;
  opacity: 0;
  pointer-events: none;

  /* nice fade */
  transition: opacity .18s ease;
  isolation: isolate;

  /* your overlay dim */
  background: rgba(0,0,0,.82);

  /* flex baseline (enabled when .is-visible) */
  align-items: stretch;
  justify-content: center;
}

/* Main chat overlay fills vertically */
#valki-root .valki-overlay{
  align-items: stretch;
  justify-content: center;
}

/* Centered overlays (auth/confirm/logout) */
#valki-root .valki-auth-overlay,
#valki-root .valki-confirm-overlay,
#valki-root .valki-logout-overlay{
  align-items: center;
  justify-content: center;
}

/* Fullscreen modal follows the same vh logic */
#valki-root .valki-modal{
  height: var(--vvh);
  width: 100%;
}

/* Visible state */
#valki-root .valki-overlay.is-visible,
#valki-root .valki-auth-overlay.is-visible,
#valki-root .valki-confirm-overlay.is-visible,
#valki-root .valki-logout-overlay.is-visible{
  display: flex;
  opacity: 1;
  pointer-events: auto;
}

/* ===============================
   AUTH MODAL â€“ FIXED CARD LAYOUT
================================ */

#valki-root .valki-auth-modal{
  width: 100%;
  max-width: 420px;
  margin: 0 16px;

  background: rgba(12,12,12,.92);
  backdrop-filter: blur(18px) saturate(120%);
  -webkit-backdrop-filter: blur(18px) saturate(120%);

  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.14);
  box-shadow: 0 30px 90px rgba(0,0,0,.65);

  padding: 22px 22px 20px;
  text-align: center;

  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Avatar/logo bovenin netjes klein */
#valki-root .valki-auth-avatar{
  width: 72px;
  height: 72px;
  border-radius: 50%;
  margin-bottom: 14px;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(255,255,255,.04);
}

/* Titel */
#valki-root .valki-auth-title{
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 6px;
}

/* Subtitel */
#valki-root .valki-auth-subtitle{
  font-size: 13px;
  color: rgba(255,255,255,.65);
  margin-bottom: 18px;
}

/* Buttons stack */
#valki-root .valki-auth-buttons{
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 14px;
}

/* Buttons */
#valki-root .valki-auth-btn{
  width: 100%;
  padding: 10px 14px;
  border-radius: 12px;
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.14);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  font-size: 14px;
}

#valki-root .valki-auth-btn.primary{
  background: #f2f2f2;
  color: #0b0b0b;
}

/* Footer tekst */
#valki-root .valki-auth-note{
  font-size: 11px;
  color: rgba(255,255,255,.55);
  margin-bottom: 8px;
}

/* Dismiss */
#valki-root .valki-auth-dismiss{
  font-size: 12px;
  color: rgba(255,255,255,.7);
  cursor: pointer;
}

/* ===============================
   AUTH BUTTON HOVER â€“ FIXED
================================ */

#valki-root .valki-auth-btn{
  cursor: pointer;
  transition:
    transform .12s ease,
    box-shadow .12s ease,
    border-color .12s ease,
    background .12s ease,
    filter .12s ease;
}

/* ---------- DEFAULT (dark buttons) ---------- */
@media (hover:hover){
  #valki-root .valki-auth-btn:not(.primary):hover{
    transform: translateY(-1px);
    background: rgba(255,255,255,.09);
    border-color: rgba(255,255,255,.22);
    box-shadow: 0 14px 34px rgba(0,0,0,.35);
  }
}

/* ---------- PRIMARY (white button) ---------- */
@media (hover:hover){
  #valki-root .valki-auth-btn.primary:hover{
    transform: translateY(-1px);
    background: #f2f2f2;              /* blijft wit */
    border-color: rgba(0,0,0,.08);
    box-shadow: 0 18px 44px rgba(0,0,0,.38);
    filter: brightness(1.01);         /* subtiel, geen grijs */
  }
}

/* Pressed */
#valki-root .valki-auth-btn:active{
  transform: translateY(0) scale(.99);
}

/* Keyboard focus */
#valki-root .valki-auth-btn:focus-visible{
  outline: none;
  box-shadow:
    0 0 0 2px var(--ring),
    0 18px 44px rgba(0,0,0,.38);
}

/* =========================================================
   Modal + Background + Vignette + Side Blur  (FIX)
========================================================= */
#valki-root .valki-modal{
  width:100vw;
  height:100vh;
  height:100dvh;

  /* IMPORTANT: use your background image variable */
  background:
    var(--chat-bg-image) center / cover no-repeat,
    linear-gradient(#0c0c0c,#070707);
  background-color: var(--chat-bg-color);

  border-radius:0;
  overflow:hidden;
  display:flex;
  flex-direction:column;

  position: relative;
  isolation: isolate;

  /* Outer â€œblock presenceâ€ */
  box-shadow:
    0 0 0 1px rgba(255,255,255,.04),
    0 30px 80px rgba(0,0,0,.65);
}

/* =========================================================
   VIGNETTE + SIDE BLUR OUTSIDE CHAT BLOCK (REPLACES OLD ::before/::after)
========================================================= */

/* Put vignette inside modal background layers */
#valki-root .valki-modal{
  background:
    /* Vignette */
    radial-gradient(
      120% 100% at 50% 45%,
      rgba(0,0,0,0) 0%,
      rgba(0,0,0,0) 42%,
      rgba(0,0,0, calc(var(--vignette-strength, .58) * .42)) 68%,
      rgba(0,0,0, var(--vignette-strength, .58)) 100%
    ),
    /* Your background image */
    var(--chat-bg-image) center / cover no-repeat,
    /* Fallback */
    linear-gradient(#0c0c0c,#070707);

  background-color: var(--chat-bg-color, #070707);

  position: relative;
  isolation: isolate;

  /* Calculate chat block width (col + 2*gutter) */
  --chat-block-w: min(100vw, calc(var(--col) + (var(--gutter) * 2)));
  --side-w: max(0px, calc((100vw - var(--chat-block-w)) / 2));
}

/* LEFT side blur panel */
#valki-root .valki-modal::before{
  content:"";
  position:absolute;
  top:0;
  bottom:0;
  left:0;
  width: var(--side-w);
  z-index:1;
  pointer-events:none;

  background: rgba(0,0,0,.18); /* transparant maar definieert de blur-zone */
  backdrop-filter: blur(var(--side-blur, 18px)) saturate(115%);
  -webkit-backdrop-filter: blur(var(--side-blur, 18px)) saturate(115%);

  box-shadow: inset -1px 0 rgba(255,255,255,.06);
}

/* RIGHT side blur panel */
#valki-root .valki-modal::after{
  content:"";
  position:absolute;
  top:0;
  bottom:0;
  right:0;
  width: var(--side-w);
  z-index:1;
  pointer-events:none;

  background: rgba(0,0,0,.18);
  backdrop-filter: blur(var(--side-blur, 18px)) saturate(115%);
  -webkit-backdrop-filter: blur(var(--side-blur, 18px)) saturate(115%);

  box-shadow: inset 1px 0 rgba(255,255,255,.06);
}

/* Keep real UI above blur panels */
#valki-root .valki-modal > *{
  position: relative;
  z-index: 2;
}

/* Mobile: disable side blur panels */
@media (max-width: 640px){
  #valki-root .valki-modal::before,
  #valki-root .valki-modal::after{
    display:none;
  }
}

/* Ensure actual UI sits above overlays */
#valki-root .valki-modal > *{
  position: relative;
  z-index: 2;
}

/* =========================================================
   Header â€” HARD column lock
========================================================= */
#valki-root .valki-modal-header{
  padding: calc(10px + env(safe-area-inset-top)) var(--gutter) 10px;
  border-bottom: 1px solid rgba(255,255,255,.08);

  /* Let block styling control background */
  background: transparent;
  backdrop-filter: none;
}

#valki-root .valki-modal-header-inner{
  max-width: var(--col) !important;
  width: 100% !important;
  margin: 0 auto !important;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;
  padding-left: 0 !important;
  padding-right: 0 !important;
}

#valki-root .valki-header-left{ display:flex; align-items:center; gap: 10px; min-width:0; }

#valki-root .valki-header-avatar{
  width:30px;height:30px;border-radius:50%;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(255,255,255,.05);
  flex:0 0 auto;
}

#valki-root .valki-modal-title-text{ display:flex; flex-direction:column; min-width:0; }
#valki-root .valki-modal-title-text .name{
  font-size: 14px;
  font-weight: 720;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
#valki-root .valki-modal-title-text .session{
  font-size: 11px;
  color: var(--muted-2);
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

#valki-root .valki-header-actions{ display:flex; align-items:center; gap: 8px; }

#valki-root .valki-pill{
  padding: 7px 10px;
  border-radius: var(--radius-pill);
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(255,255,255,.10);
  font-size: 12px;
  color: rgba(255,255,255,.86);
  transition: transform .12s ease, background .12s ease, border-color .12s ease;
}
#valki-root .valki-pill:hover{
  transform: translateY(-1px);
  background: rgba(255,255,255,.06);
  border-color: rgba(255,255,255,.16);
}
#valki-root .valki-pill.primary{
  background: #f2f2f2;
  border-color: rgba(255,255,255,.20);
  color: #101010;
}
#valki-root .valki-close-btn{
  width:30px;height:30px;
  border-radius:50%;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  display:flex;align-items:center;justify-content:center;
}

/* =========================================================
   STRONG CHAT BLOCK (FINAL)
   - Makes header/messages/composer read like ONE block
========================================================= */
#valki-root .valki-modal > .valki-modal-header,
#valki-root .valki-modal > .valki-messages,
#valki-root .valki-modal > .valki-chat-form{
  background: var(--chat-block-bg);
  backdrop-filter: blur(var(--chat-block-blur));
  -webkit-backdrop-filter: blur(var(--chat-block-blur));

  border-left: 1px solid var(--chat-block-border);
  border-right: 1px solid var(--chat-block-border);
}

#valki-root .valki-modal > .valki-modal-header{
  border-top: 1px solid rgba(255,255,255,.12);
}

#valki-root .valki-modal > .valki-chat-form{
  border-bottom: 1px solid rgba(255,255,255,.12);
}

/* Small highlights for depth */
#valki-root .valki-modal > .valki-modal-header,
#valki-root .valki-modal > .valki-chat-form{
  position: relative;
}
#valki-root .valki-modal > .valki-modal-header::after{
  content:"";
  position:absolute;
  left:0; right:0; bottom:0;
  height:1px;
  background: rgba(255,255,255,.06);
  pointer-events:none;
}
#valki-root .valki-modal > .valki-chat-form::before{
  content:"";
  position:absolute;
  left:0; right:0; top:0;
  height:1px;
  background: rgba(255,255,255,.06);
  pointer-events:none;
}

#valki-root .valki-messages,
#valki-root .valki-messages-inner{
  overflow-anchor: none;
}

/* =========================================================
   Messages â€” HARD column lock
========================================================= */
#valki-root .valki-messages{
  flex:1 1 auto;
  min-height:0;
  overflow-y:auto;
  overscroll-behavior:contain;
  -webkit-overflow-scrolling:touch;
  padding: 18px 0 10px;
  display: block !important;
  width: 100% !important;
  scrollbar-width:thin;
  scrollbar-color: rgba(255,255,255,.22) transparent;
}

#valki-root .valki-messages::-webkit-scrollbar{ width: 8px; }
#valki-root .valki-messages::-webkit-scrollbar-track{ background: transparent; }
#valki-root .valki-messages::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.18);
  border-radius: 999px;
  border: 2px solid rgba(0,0,0,.55);
}
#valki-root .valki-messages::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.26); }

#valki-root .valki-messages-inner{
  max-width: var(--col) !important;
  width: 100% !important;
  margin: 0 auto !important;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
}

#valki-root .valki-messages-inner:empty{ min-height: 220px; }

#valki-root .valki-msg-row{
  display:flex;
  margin: 14px 0;
  gap: 10px;
  max-width: var(--col) !important;
  margin-left: auto !important;
  margin-right: auto !important;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
}
#valki-root .valki-msg-row.user{ justify-content:flex-end; }
#valki-root .valki-msg-row.bot{ justify-content:flex-start; }

#valki-root .valki-bot-avatar-wrap{ flex:0 0 auto; padding-top: 2px; }
#valki-root .valki-bot-avatar{
  width:26px;height:26px;border-radius:50%;
  border: 1px solid rgba(255,255,255,.16);
  background: rgba(255,255,255,.05);
}

#valki-root .valki-msg-bubble{
  max-width: 680px;
  width: fit-content;
  padding: 10px 14px;
  border-radius: var(--radius);
  line-height: 1.58;
  font-size: 15px;
  color: rgba(255,255,255,.92);
  background: transparent;
  word-wrap: break-word;
  user-select:text;
}

#valki-root .valki-msg-row.bot .valki-msg-bubble{
  background: rgba(255,255,255,.035);
  border: 1px solid rgba(255,255,255,.08);
}

#valki-root .valki-msg-row.user .valki-msg-bubble{
  background: #f1f1f1;
  border: 1px solid rgba(255,255,255,.20);
  color: #0b0b0b;
  box-shadow: 0 10px 28px rgba(0,0,0,.30);
}

#valki-root .valki-msg-bubble a{
  color: var(--brand-2);
  text-decoration:none;
  font-weight: 650;
}
#valki-root .valki-msg-bubble a:hover{ text-decoration:underline; }

#valki-root .valki-msg-bubble code{
  font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  font-size: 13px;
  background: rgba(255,255,255,.08);
  padding: 1px 5px;
  border-radius: 6px;
}

#valki-root .valki-typing-bar{ display:inline-flex; align-items:center; gap: 8px; }
#valki-root .valki-typing-dots{ display:inline-flex; gap: 4px; }
#valki-root .valki-typing-dots span{
  width:6px;height:6px;border-radius:50%;
  background: rgba(255,255,255,.72);
  animation: valkiBounce 1.2s infinite ease-in-out;
}
#valki-root .valki-typing-dots span:nth-child(2){ animation-delay:.15s; }
#valki-root .valki-typing-dots span:nth-child(3){ animation-delay:.30s; }

@keyframes valkiBounce{
  0%,60%,100%{ transform:translateY(0); opacity:.45; }
  30%{ transform:translateY(-3px); opacity:1; }
}
#valki-root .valki-typing-label{ font-size:12px; color: var(--muted); }

/* =========================================================
   Composer â€” HARD column lock
========================================================= */
#valki-root .valki-chat-form{
  border-top: 1px solid rgba(255,255,255,.08);
  background: transparent;
  backdrop-filter: none;
  padding: 12px 0 var(--valki-chat-pad-bottom) !important;
}

#valki-root .valki-chat-form-inner{
  max-width: var(--col) !important;
  width: 100% !important;
  margin: 0 auto !important;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
}

#valki-root .valki-chat-inner{
  display:flex;
  align-items:flex-end;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 26px;
  background: rgba(255,255,255,.045);
  border: 1px solid rgba(255,255,255,.12);
  box-shadow: 0 18px 60px rgba(0,0,0,.55);
  transition: border-color .15s ease, background .15s ease, box-shadow .15s ease;
}

#valki-root .valki-chat-inner:focus-within{
  background: rgba(255,255,255,.055);
  border-color: rgba(255,255,255,.20);
  box-shadow: 0 20px 70px rgba(0,0,0,.62), 0 0 0 3px var(--ring);
}

#valki-root .valki-chat-attach{
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: rgba(255,255,255,.05);
  border: 1px solid rgba(255,255,255,.12);
  display:flex;
  align-items:center;
  justify-content:center;
  color: rgba(255,255,255,.86);
  transition: transform .12s ease, background .12s ease, border-color .12s ease, opacity .12s ease;
}
#valki-root .valki-chat-attach:hover{
  transform: translateY(-1px);
  background: rgba(255,255,255,.08);
  border-color: rgba(255,255,255,.18);
}
#valki-root .valki-chat-attach[disabled]{ opacity:.55; pointer-events:none; }

#valki-root .valki-chat-input{
  flex: 1 1 auto;
  min-width: 0;
  padding: 10px 2px;
  border:none;
  background: transparent;
  color: rgba(255,255,255,.92);
  font-size: 16px;
  line-height: 1.5;
  resize:none;
  overflow-y:hidden;
  white-space: pre-wrap;
  word-break: break-word;
  caret-color: rgba(255,255,255,.86);
}
#valki-root .valki-chat-input::placeholder{ color: rgba(255,255,255,.30); }

#valki-root .valki-chat-send{
  width: 42px;
  height: 42px;
  border-radius: 50%;
  background: var(--btn-fill);
  color: var(--btn-text);
  border: 1px solid rgba(255,255,255,.16);
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow: 0 10px 26px rgba(0,0,0,.35);
  transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
}
#valki-root .valki-chat-send:hover{
  transform: translateY(-1px);
  box-shadow: 0 14px 34px rgba(0,0,0,.42);
}
#valki-root .valki-chat-send[disabled]{ opacity:.55; pointer-events:none; }

/* Attachments tray */
#valki-root .valki-attachments{
  max-width: var(--col) !important;
  margin: 10px auto 0;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
}

/* âœ… Attachments thumbnails (was missing -> "buggy" feel) */
#valki-root .valki-attachment{
  position: relative;
  width: 58px;
  height: 58px;
  border-radius: 14px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  box-shadow: 0 10px 26px rgba(0,0,0,.35);
}

#valki-root .valki-attachment img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

#valki-root .valki-attachment-remove{
  position: absolute;
  top: 6px;
  right: 6px;
  width: 22px;
  height: 22px;
  border-radius: 999px;
  background: rgba(0,0,0,.55);
  border: 1px solid rgba(255,255,255,.18);
  color: rgba(255,255,255,.92);
  display:flex;
  align-items:center;
  justify-content:center;
  line-height: 1;
}

/* =========================================================
   Extra blur + â€œblokâ€ feel voor composer (vooral mobiel)
========================================================= */

/* Composer background (het hele onderste blok) */
#valki-root .valki-chat-form{
  background: rgba(0,0,0,.30); /* iets donkerder zodat blur beter leest */
  backdrop-filter: blur(18px) saturate(120%);
  -webkit-backdrop-filter: blur(18px) saturate(120%);
}

/* De pill zelf (verzendbalk / input container) */
#valki-root .valki-chat-inner{
  background: rgba(12,12,12,.38);
  backdrop-filter: blur(22px) saturate(125%);
  -webkit-backdrop-filter: blur(22px) saturate(125%);

  border: 1px solid rgba(255,255,255,.14);
  box-shadow: 0 18px 60px rgba(0,0,0,.55);
}

/* Buttons ook iets â€œglassyâ€ */
#valki-root .valki-chat-attach,
#valki-root .valki-chat-send{
  backdrop-filter: blur(14px) saturate(120%);
  -webkit-backdrop-filter: blur(14px) saturate(120%);
}

/* Mobile: blur extra boosten + iets meer tint (werkt beter op iOS/Android) */
@media (max-width: 640px){
  #valki-root .valki-chat-form{
    background: rgba(0,0,0,.36);
    backdrop-filter: blur(22px) saturate(125%);
    -webkit-backdrop-filter: blur(22px) saturate(125%);
  }

  #valki-root .valki-chat-inner{
    background: rgba(10,10,10,.48);
    backdrop-filter: blur(28px) saturate(130%);
    -webkit-backdrop-filter: blur(28px) saturate(130%);
  }
}

/* Fallback als backdrop-filter niet supported is (B2B-proof) */
@supports not ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))){
  #valki-root .valki-chat-form{
    background: rgba(0,0,0,.62);
  }
  #valki-root .valki-chat-inner{
    background: rgba(12,12,12,.72);
  }
}

/* =========================================================
   Composer + disclaimer = Ã©Ã©n glass block
========================================================= */

/* Disclaimer onderdeel maken van de glass look */
#valki-root .valki-disclaimer{
  margin-top: 8px;
  padding: 6px 12px 0;
  color: rgba(255,255,255,.62);

  /* subtiele scheiding maar geen â€œlos blokâ€ gevoel */
  border-top: 1px solid rgba(255,255,255,.08);

  /* zelf geen blur nodig â€” valt visueel binnen de parent */
  background: transparent;
}

/* Cookie button iets cleaner/glassy */
#valki-root .valki-disclaimer-button{
  background: transparent;
  border: none;
  color: rgba(255,255,255,.70);
  font-size: 11px;
  text-decoration: underline;
  cursor: pointer;
}

#valki-root .valki-disclaimer-button:hover{
  color: rgba(255,255,255,.85);
}

/* Mobile: disclaimer sterker integreren in blur-blok */
@media (max-width: 640px){
  #valki-root .valki-disclaimer{
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,.10);
    color: rgba(255,255,255,.70);
  }
}

/* Disclaimer */
#valki-root .valki-disclaimer{
  max-width: var(--col) !important;
  margin: 6px auto 0 !important;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
  font-size: 11px;
  line-height: 1.4;
  color: rgba(255,255,255,.55);
  text-align:center;
}

/* Keep last messages visible â€” dynamic (composer height + safe area + 2px) */
html.valki-chat-open #valki-root{
  --composer-h: 110px; /* fallback; JS zet â€˜m exact */
}

html.valki-chat-open #valki-root .valki-messages-inner{
  padding-bottom: calc(var(--composer-h, 110px) + env(safe-area-inset-bottom) + 2px) !important;
}

/* Optional: makes wheel/touch scroll land nicely above composer */
html.valki-chat-open #valki-root .valki-messages{
  scroll-padding-bottom: calc(var(--composer-h, 110px) + env(safe-area-inset-bottom) + 2px);
}

/* Mobile tweaks + disable vignette/blur */
@media (max-width:640px){
  #valki-root{
    --gutter: 14px;
    --col: 720px;
  }

  #valki-root .valki-modal{
    box-shadow: none;
  }

  #valki-root .valki-modal::before,
  #valki-root .valki-modal::after{
    display:none;
  }

  #valki-root .valki-modal > .valki-modal-header,
  #valki-root .valki-modal > .valki-messages,
  #valki-root .valki-modal > .valki-chat-form{
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
    border-left: none;
    border-right: none;
  }

  #valki-root .valki-chat-attach{ width: 38px; height: 38px; }
  #valki-root .valki-chat-send{ width: 38px; height: 38px; }
  #valki-root .valki-bubble{
    right: 14px;
    bottom: calc(14px + env(safe-area-inset-bottom));
    width: 62px;
    height: 62px;
  }
}

/* =========================================================
   Bot message bubble â€” subtle glass blur for readability
========================================================= */

#valki-root .valki-msg-row.bot .valki-msg-bubble{
  background: rgba(20,20,20,.42); /* iets transparant */
  border: 1px solid rgba(255,255,255,.10);

  backdrop-filter: blur(7px) saturate(120%);
  -webkit-backdrop-filter: blur(7px) saturate(120%);

  box-shadow:
    0 8px 28px rgba(0,0,0,.35),
    inset 0 1px rgba(255,255,255,.04);

  color: rgba(255,255,255,.94);
}

@media (max-width: 640px){
  #valki-root .valki-msg-row.bot .valki-msg-bubble{
    background: rgba(16,16,16,.52);
    backdrop-filter: blur(14px) saturate(125%);
    -webkit-backdrop-filter: blur(14px) saturate(125%);
  }
}

@supports not ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))){
  #valki-root .valki-msg-row.bot .valki-msg-bubble{
    background: rgba(20,20,20,.75);
  }
}

/* Utility */
#valki-root .valki-hidden{ display:none !important; }
`\n
exports.sharedCss = sharedCss;

},
'src/themes/valki.js': (module, exports, __require) => {
const { sharedCss } = __require('src/themes/shared.js');

const valkiTheme = {
  name: 'valki',
  title: 'Valki Talki',
  bubbleLabel: 'Open Valki chat',
  overlayTitle: 'Valki Talki',
  avatarUrl: 'https://valki.wiki/blogmedia/Valki%20Talki.jpg',
  css: sharedCss,
  overrideCss: ''
};

exports.valkiTheme = valkiTheme;

},
'src/themes/vichat.js': (module, exports, __require) => {
const { sharedCss } = __require('src/themes/shared.js');

const vichatTheme = {
  name: 'vichat',
  title: 'ViChat',
  bubbleLabel: 'Open ViChat chat',
  overlayTitle: 'ViChat',
  avatarUrl: 'https://valki.wiki/blogmedia/Valki%20Talki.jpg',
  css: sharedCss,
  overrideCss: ''
};

exports.vichatTheme = vichatTheme;

},
'src/themes/index.js': (module, exports, __require) => {
const { valkiTheme } = __require('src/themes/valki.js');
const { vichatTheme } = __require('src/themes/vichat.js');

const THEMES = {
  vichat: vichatTheme,
  valki: valkiTheme
};

function resolveTheme(name) {
  if (name && THEMES[name]) return THEMES[name];
  return vichatTheme;
}

function getAllThemes() {
  return Object.values(THEMES);
}

exports.resolveTheme = resolveTheme;
exports.getAllThemes = getAllThemes;

},
'src/index.js': (module, exports, __require) => {
const { templateHtml } = __require('src/core/ui/template.js');
const { buildConfig } = __require('src/core/config.js');
const {
  cleanText,
  clearAuthToken,
  clearGuestHistory,
  getAuthToken,
  getOrCreateClientId,
  loadGuestHistory,
  markBubbleSeen,
  saveGuestHistory,
  setAuthToken,
  shouldShowBubbleBadge
} = __require('src/core/storage.js');
const { createAttachmentController } = __require('src/core/attachments.js');
const { createGuestMeter } = __require('src/core/guestMeter.js');
const { createMessageController } = __require('src/core/ui/messages.js');
const { createComposerController } = __require('src/core/ui/composer.js');
const { createOverlayController, setVisible } = __require('src/core/ui/overlay.js');
const { createAuthController } = __require('src/core/auth.js');
const { askValki, clearMessages, fetchMe, fetchMessages, importGuestMessages } = __require('src/core/api.js');
const { resolveTheme } = __require('src/themes/index.js');

const REQUIRED_IDS = [
  'valki-root',
  'valki-bubble',
  'valki-bubble-badge',
  'valki-bubble-ping',
  'valki-overlay',
  'valki-close',
  'valki-header-avatar',
  'valki-title',
  'valki-session-label',
  'valki-loginout-btn',
  'valki-deleteall-btn',
  'valki-messages',
  'valki-messages-inner',
  'valki-chat-form',
  'valki-chat-input',
  'valki-chat-send',
  'valki-chat-attach',
  'valki-file-input',
  'valki-attachments',
  'valki-auth-overlay',
  'valki-auth-title',
  'valki-auth-subtitle',
  'valki-auth-note',
  'valki-auth-dismiss',
  'valki-login-discord-btn',
  'valki-login-google-btn',
  'valki-join-discord-btn',
  'valki-confirm-overlay',
  'valki-confirm-no',
  'valki-confirm-yes',
  'valki-logout-overlay',
  'valki-logout-no',
  'valki-logout-yes'
];

function ensureStyle(theme) {
  const styleId = `vichat-theme-${theme.name}`;
  if (document.getElementById(styleId)) return;
  const style = document.createElement('style');
  style.id = styleId;
  style.textContent = [theme.css, theme.overrideCss].filter(Boolean).join('\n');
  document.head.appendChild(style);
}

function mountTemplate(theme, target) {
  const existing = document.getElementById('valki-root');
  if (existing) {
    const body = document.body;
    if (body?.dataset?.valkiScrollY) {
      body.style.position = '';
      body.style.top = '';
      body.style.left = '';
      body.style.right = '';
      body.style.width = '';
      body.style.overflow = '';
      body.style.touchAction = '';
      delete body.dataset.valkiScrollY;
    }
    document.documentElement.classList.remove('valki-chat-open');
    existing.remove();
  }

  const container = document.createElement('div');
  container.innerHTML = templateHtml;
  const root = container.querySelector('#valki-root');
  if (!root) throw new Error('ViChat root not found in template');

  const targetEl = target || document.body || document.documentElement;
  targetEl.appendChild(root);

  const elements = {};
  REQUIRED_IDS.forEach((id) => {
    elements[id] = root.querySelector(`#${id}`);
  });

  const missing = Object.entries(elements)
    .filter(([, value]) => !value)
    .map(([id]) => id);
  if (missing.length) {
    throw new Error(`ViChat mount failed. Missing elements: ${missing.join(', ')}`);
  }

  elements['valki-root'].style.setProperty('--valki-vh', `${(window.innerHeight || 0) * 0.01}px`);

  elements['valki-title'].textContent = theme.overlayTitle || theme.title || 'ViChat';
  elements['valki-bubble'].setAttribute('aria-label', theme.bubbleLabel || 'Open chat');
  elements['valki-header-avatar'].src = theme.avatarUrl || elements['valki-header-avatar'].src;

  return elements;
}

class ViChatWidget {
  constructor(options = {}) {
    this.config = buildConfig(options);
    this.theme = resolveTheme(this.config.theme);
    this.token = getAuthToken(this.config);
    this.clientId = getOrCreateClientId(this.config);
    this.me = null;
    this.authHard = false;
    this.isSending = false;
    this.guestHistory = [];
    this.elements = null;
    this.attachmentController = null;
    this.messageController = null;
    this.composerController = null;
    this.overlayController = null;
    this.guestMeter = null;
    this.authController = null;
    this._layoutRaf = 0;
  }

  mount(mountTarget) {
    ensureStyle(this.theme);
    this.elements = mountTemplate(this.theme, mountTarget);
    this.bindUi();
    void this.boot();
  }

  bindUi() {
    const el = this.elements;

    const updateComposerHeight = () => {
      try {
        const rect = el['valki-chat-form'].getBoundingClientRect();
        const h = Math.max(0, Math.round(rect?.height || 0));
        if (h) el['valki-root'].style.setProperty('--composer-h', `${h}px`);
      } catch {
        /* ignore */
      }
    };

    const scheduleLayoutMetrics = () => {
      if (this._layoutRaf) cancelAnimationFrame(this._layoutRaf);
      this._layoutRaf = requestAnimationFrame(() => {
        updateComposerHeight();
        this.updateValkiVh();
      });
    };

    const clampComposer = () => this.composerController?.clampComposer();

    this.composerController = createComposerController({
      chatInput: el['valki-chat-input'],
      chatForm: el['valki-chat-form'],
      config: this.config,
      updateComposerHeight
    });

    this.overlayController = createOverlayController({
      overlay: el['valki-overlay'],
      chatInput: el['valki-chat-input'],
      updateComposerHeight,
      clampComposer,
      scrollToBottom: (force) => this.messageController?.scrollToBottom(force)
    });

    this.guestMeter = createGuestMeter({
      config: this.config,
      isLoggedIn: () => this.isLoggedIn()
    });

    this.messageController = createMessageController({
      messagesEl: el['valki-messages'],
      messagesInner: el['valki-messages-inner'],
      avatarUrl: this.config.avatarUrl,
      updateDeleteButtonVisibility: () => this.updateDeleteButtonVisibility()
    });

    this.attachmentController = createAttachmentController({
      attachTray: el['valki-attachments'],
      attachButton: el['valki-chat-attach'],
      fileInput: el['valki-file-input'],
      clampComposer,
      updateComposerHeight,
      config: this.config
    });

    this.authController = createAuthController({
      config: this.config,
      onToken: (token) => this.handleAuthToken(token)
    });
    this.authController.attach();

    this.composerController.applyPlaceholders();
    window.addEventListener('languagechange', () => this.composerController.applyPlaceholders());

    el['valki-loginout-btn'].addEventListener('click', () => this.openAuthOverlay(false));
    el['valki-deleteall-btn'].addEventListener('click', () => this.onDeleteAll());
    el['valki-confirm-no'].addEventListener('click', () => this.closeConfirm());
    el['valki-confirm-overlay'].addEventListener('click', (e) => {
      if (e.target === el['valki-confirm-overlay']) this.closeConfirm();
    });
    el['valki-confirm-yes'].addEventListener('click', async () => {
      this.closeConfirm();
      await this.clearChatAll();
      this.updateDeleteButtonVisibility();
    });

    el['valki-logout-yes'].addEventListener('click', async () => {
      this.closeLogoutPrompt();
      await this.logout();
    });
    el['valki-logout-no'].addEventListener('click', () => this.closeLogoutPrompt());
    el['valki-logout-overlay'].addEventListener('click', (e) => {
      if (e.target === el['valki-logout-overlay']) this.closeLogoutPrompt();
    });

    el['valki-bubble'].addEventListener('click', (e) => this.openFromBubble(e));
    el['valki-chat-form'].addEventListener('submit', (e) => {
      e.preventDefault();
      const q = cleanText(el['valki-chat-input'].value);
      if (!q) return;
      el['valki-chat-input'].value = '';
      clampComposer();
      this.ask(q);
    });

    el['valki-chat-input'].addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        el['valki-chat-form'].dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
      }
    });
    el['valki-chat-input'].addEventListener('input', clampComposer);
    el['valki-chat-input'].addEventListener('paste', () => setTimeout(clampComposer, 0));

    el['valki-chat-attach'].addEventListener('click', () => {
      if (el['valki-chat-input'].disabled || this.isSending) return;
      el['valki-file-input'].click();
    });

    el['valki-file-input'].addEventListener('change', async () => {
      await this.attachmentController.addFiles(el['valki-file-input'].files);
      el['valki-file-input'].value = '';
      clampComposer();
      scheduleLayoutMetrics();
    });

    el['valki-close'].addEventListener('click', () => this.overlayController.closeOverlay());

    document.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;
      if (el['valki-logout-overlay'].classList.contains('is-visible')) {
        this.closeLogoutPrompt();
        return;
      }
      if (el['valki-confirm-overlay'].classList.contains('is-visible')) {
        this.closeConfirm();
        return;
      }
      if (el['valki-auth-overlay'].classList.contains('is-visible')) {
        if (!this.authHard) this.closeAuthOverlay();
        return;
      }
      if (this.overlayController.isChatOpen()) this.overlayController.closeOverlay();
    });

    const accountTriggers = [
      el['valki-header-avatar'],
      el['valki-title'],
      el['valki-session-label']
    ];
    accountTriggers.forEach((node) => {
      node.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.isLoggedIn()) this.openLogoutPrompt();
        else this.openAuthOverlay(false);
      });
    });

    el['valki-login-discord-btn'].addEventListener('click', () => this.authController.openDiscordLogin());
    el['valki-login-google-btn'].addEventListener('click', () => this.authController.openGoogleLogin());
    el['valki-join-discord-btn'].addEventListener('click', () => this.authController.openDiscordInvite());

    el['valki-auth-dismiss'].addEventListener('click', () => this.closeAuthOverlay());
    el['valki-auth-overlay'].addEventListener('click', (event) => {
      if (event.target === el['valki-auth-overlay']) this.closeAuthOverlay();
    });

    window.addEventListener(
      'resize',
      () => {
        scheduleLayoutMetrics();
        this.messageController.scrollToBottom(false);
      },
      { passive: true }
    );
    window.addEventListener(
      'orientationchange',
      () => setTimeout(() => {
        scheduleLayoutMetrics();
        this.messageController.scrollToBottom(false);
      }, 60),
      { passive: true }
    );

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', () => {
        updateComposerHeight();
        this.messageController.scrollToBottom(false);
      });
    }

    if (document.fonts && document.fonts.ready) {
      document.fonts.ready
        .then(() => {
          if (document.activeElement === el['valki-chat-input']) clampComposer();
          scheduleLayoutMetrics();
        })
        .catch(() => {});
    }

    this.scheduleLayoutMetrics = scheduleLayoutMetrics;
    this.updateComposerHeight = updateComposerHeight;
    this.updateValkiVh = this.updateValkiVh.bind(this);
  }

  updateValkiVh() {
    try {
      const vv = window.visualViewport;
      const height = vv && vv.height ? vv.height : window.innerHeight;
      this.elements['valki-root'].style.setProperty('--valki-vh', `${height * 0.01}px`);
    } catch {
      /* ignore */
    }
  }

  isLoggedIn() {
    return !!this.token;
  }

  updateSessionLabel() {
    const sessionLabel = this.elements['valki-session-label'];
    if (this.me && this.me.name) {
      sessionLabel.textContent = `${this.me.name} ðŸŸ¢`;
      return;
    }
    sessionLabel.textContent = this.isLoggedIn() ? 'you ðŸŸ¢' : 'Guest ðŸŸ ';
  }

  updateLoginOutButtonLabel() {
    const btn = this.elements['valki-loginout-btn'];
    if (this.isLoggedIn()) {
      btn.style.display = 'none';
    } else {
      btn.style.display = 'inline-flex';
      btn.textContent = 'Login';
    }
  }

  updateDeleteButtonVisibility() {
    const btn = this.elements['valki-deleteall-btn'];
    btn.style.display = this.messageController.hasAnyRealMessages() ? 'inline-flex' : 'none';
  }

  updateDeleteButtonState(isBusy) {
    if (!this.messageController.hasAnyRealMessages()) return;
    const btn = this.elements['valki-deleteall-btn'];
    btn.disabled = !!isBusy;
    btn.style.opacity = isBusy ? '.55' : '';
    btn.style.pointerEvents = isBusy ? 'none' : '';
  }

  showBubbleBadge(label = '1') {
    this.elements['valki-bubble-badge'].style.display = 'flex';
    this.elements['valki-bubble-badge'].textContent = String(label);
    this.elements['valki-bubble-ping'].style.display = 'block';
  }

  hideBubbleBadge() {
    this.elements['valki-bubble-badge'].style.display = 'none';
    this.elements['valki-bubble-ping'].style.display = 'none';
  }

  openAuthOverlay(hard) {
    this.authHard = !!hard;
    const el = this.elements;
    el['valki-auth-title'].textContent = this.authHard ? 'Login required' : 'Log in to continue';
    el['valki-auth-subtitle'].textContent = this.authHard
      ? 'Youâ€™ve reached the guest limit. Log in to keep chatting.'
      : 'Sign in to keep your chat history and manage messages.';
    el['valki-auth-note'].textContent = this.authHard ? 'Guest limit reached.' : 'Tip: you can continue as guest, but limits apply.';
    el['valki-auth-dismiss'].style.display = this.authHard ? 'none' : 'inline-block';
    setVisible(el['valki-auth-overlay'], true);

    if (this.authHard) {
      el['valki-chat-input'].disabled = true;
      el['valki-chat-send'].disabled = true;
      this.attachmentController.setDisabled(true, true);
      this.updateDeleteButtonState(true);
    }
  }

  closeAuthOverlay(force = false) {
    if (this.authHard && !force) return;
    const el = this.elements['valki-auth-overlay'];
    el.classList.remove('is-visible');
    el.setAttribute('aria-hidden', 'true');
    setTimeout(() => {
      el.style.display = 'none';
    }, 180);
  }

  openConfirm() {
    setVisible(this.elements['valki-confirm-overlay'], true);
  }

  closeConfirm() {
    const el = this.elements['valki-confirm-overlay'];
    el.classList.remove('is-visible');
    el.setAttribute('aria-hidden', 'true');
    setTimeout(() => {
      el.style.display = 'none';
    }, 180);
  }

  openLogoutPrompt() {
    setVisible(this.elements['valki-logout-overlay'], true);
  }

  closeLogoutPrompt() {
    const el = this.elements['valki-logout-overlay'];
    el.classList.remove('is-visible');
    el.setAttribute('aria-hidden', 'true');
    setTimeout(() => {
      el.style.display = 'none';
    }, 180);
  }

  async handleAuthToken(token) {
    this.token = token;
    setAuthToken(token, this.config);
    await this.loadMe();
    this.updateSessionLabel();
    this.updateLoginOutButtonLabel();
    this.guestMeter.reset();

    this.elements['valki-chat-input'].disabled = false;
    this.elements['valki-chat-send'].disabled = false;
    this.attachmentController.setDisabled(false, false);
    this.updateDeleteButtonState(false);
    this.authHard = false;
    this.closeAuthOverlay(true);

    await importGuestMessages({
      token,
      guestHistory: this.guestHistory,
      config: this.config
    });
    this.guestHistory = [];
    clearGuestHistory(this.config);
    await this.loadLoggedInMessagesToUI({ forceOpen: true });
  }

  async loadMe() {
    this.me = await fetchMe({ token: this.token, config: this.config });
  }

  async loadLoggedInMessagesToUI({ forceOpen = false } = {}) {
    if (!this.token) return false;
    const { ok, messages } = await fetchMessages({ token: this.token, config: this.config });
    if (!ok && !messages.length) return false;
    this.messageController.clearMessagesUI();
    for (const m of messages || []) {
      await this.messageController.addMessage({ type: m.role, text: m.text });
    }
    this.messageController.scrollToBottom(true);
    this.updateDeleteButtonVisibility();
    this.scheduleLayoutMetrics?.();
    if (forceOpen && !this.overlayController.isChatOpen()) this.overlayController.openOverlay();
    return true;
  }

  async clearChatAll() {
    if (this.isLoggedIn()) {
      const ok = await clearMessages({ token: this.token, config: this.config });
      if (ok) {
        await this.loadLoggedInMessagesToUI();
        this.scheduleLayoutMetrics?.();
        return;
      }
      this.messageController.clearMessagesUI();
      this.scheduleLayoutMetrics?.();
      return;
    }
    this.guestHistory = [];
    saveGuestHistory(this.guestHistory, this.config);
    this.messageController.clearMessagesUI();
    this.scheduleLayoutMetrics?.();
  }

  async logout() {
    clearAuthToken(this.config);
    this.token = '';
    this.me = null;
    this.updateSessionLabel();
    this.updateLoginOutButtonLabel();

    this.elements['valki-chat-input'].disabled = false;
    this.elements['valki-chat-send'].disabled = false;
    this.attachmentController.setDisabled(false, false);

    this.attachmentController.clearAttachments();
    this.guestHistory = [];
    clearGuestHistory(this.config);
    this.guestMeter.reset();

    this.messageController.clearMessagesUI();
    await this.renderGuestHistoryToUI();
    this.scheduleLayoutMetrics?.();
  }

  async renderGuestHistoryToUI() {
    this.messageController.clearMessagesUI();
    for (const m of this.guestHistory) {
      await this.messageController.addMessage({ type: m.type, text: m.text });
    }
    this.messageController.scrollToBottom(true);
    this.updateDeleteButtonVisibility();
    this.scheduleLayoutMetrics?.();
  }

  setSendingState(isBusy) {
    const el = this.elements;
    el['valki-chat-send'].disabled = isBusy || !!el['valki-chat-input'].disabled;
    this.attachmentController.setDisabled(isBusy, el['valki-chat-input'].disabled);
    this.updateDeleteButtonState(isBusy);
  }

  async ask(text) {
    const q = cleanText(text);
    if (!q || this.isSending) return;
    if (this.guestMeter.guestHardBlocked()) {
      this.openAuthOverlay(true);
      return;
    }

    this.isSending = true;
    this.setSendingState(true);

    const imagesSnapshot = this.attachmentController.snapshot().filter((x) => x.dataUrl);

    await this.messageController.addMessage({ type: 'user', text: q });

    if (!this.isLoggedIn()) {
      this.guestHistory.push({ type: 'user', text: q });
      saveGuestHistory(this.guestHistory, this.config);
      this.guestMeter.bumpGuestCount();
    }

    const typingRow = this.messageController.createTypingRow();
    const payloadImages = imagesSnapshot;

    const persistGuestBot = (msg) => {
      if (this.isLoggedIn()) return;
      this.guestHistory.push({ type: 'bot', text: msg });
      saveGuestHistory(this.guestHistory, this.config);
      this.guestMeter.maybePromptLoginAfterSend((opts) => this.openAuthOverlay(opts.hard));
    };

    const removeTyping = () => {
      try {
        typingRow.remove();
      } catch {
        /* ignore */
      }
    };

    try {
      const res = await askValki({
        message: q,
        clientId: this.clientId,
        images: payloadImages,
        token: this.token,
        config: this.config
      });

      removeTyping();
      const reply = res.ok ? res.message : res.message || this.config.copy.genericError;
      await this.messageController.addMessage({ type: 'bot', text: reply });
      persistGuestBot(reply);
      if (res.ok) this.messageController.scrollToBottomHard();
    } catch (err) {
      console.error(err);
      removeTyping();
      await this.messageController.addMessage({ type: 'bot', text: this.config.copy.genericError });
      persistGuestBot(this.config.copy.genericError);
    } finally {
      this.isSending = false;
      this.setSendingState(false);
      this.attachmentController.clearAttachments();
      this.updateDeleteButtonVisibility();
      this.composerController.clampComposer();
      this.scheduleLayoutMetrics?.();
    }
  }

  async openFromBubble(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    markBubbleSeen(this.config);
    this.hideBubbleBadge();

    if (this.isLoggedIn()) {
      await this.loadLoggedInMessagesToUI({ forceOpen: true });
      return;
    }
    this.overlayController.openOverlay();
    await this.renderGuestHistoryToUI();
    if (this.guestMeter.guestHardBlocked()) this.openAuthOverlay(true);
  }

  onDeleteAll() {
    if (!this.messageController.hasAnyRealMessages() || this.isSending) return;
    if (this.elements['valki-auth-overlay'].classList.contains('is-visible')) return;
    this.openConfirm();
  }

  async boot() {
    await this.loadMe();
    this.updateSessionLabel();
    this.updateLoginOutButtonLabel();
    this.attachmentController.setDisabled(false);

    if (shouldShowBubbleBadge(this.config)) this.showBubbleBadge('1');

    if (this.isLoggedIn()) {
      await this.loadLoggedInMessagesToUI({ forceOpen: false });
    } else {
      this.guestHistory = loadGuestHistory(this.config);
      await this.renderGuestHistoryToUI();
    }

    this.updateDeleteButtonVisibility();
    this.scheduleLayoutMetrics?.();
    this.composerController.clampComposer();
    this.scheduleLayoutMetrics?.();
  }
}

function resolveMountTarget(options = {}) {
  if (options && options.target instanceof HTMLElement) return options.target;
  if (typeof options.target === 'string') {
    const el = document.querySelector(options.target);
    if (el) return el;
  }
  return document.body || document.documentElement;
}

function mount(options = {}) {
  const widget = new ViChatWidget(options);
  const target = resolveMountTarget(options);
  widget.mount(target);
  return widget;
}

if (typeof window !== 'undefined') {
  window.ViChat = window.ViChat || {};
  window.ViChat.mount = mount;
}

exports.mount = mount;

}
};
const __cache = {};
const __require = (id) => {
  if (__cache[id]) {
    return __cache[id].exports;
  }
  const module = { exports: {} };
  __cache[id] = module;
  __modules[id](module, module.exports, __require);
  return module.exports;
};
__require('src/index.js');
})();
