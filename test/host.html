<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Valki Talki Host Smoke</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <h1>Valki Talki Host Smoke</h1>
    <script src="/valki-talki.js"></script>
    <script>
      const waitFor = (predicate, { timeout = 8000, interval = 100 } = {}) => {
        const start = Date.now();
        return new Promise((resolve, reject) => {
          const tick = () => {
            if (predicate()) return resolve(predicate());
            if (Date.now() - start > timeout) return reject(new Error('Timeout waiting for condition'));
            setTimeout(tick, interval);
          };
          tick();
        });
      };

      const runSmoke = async () => {
        await customElements.whenDefined('valki-talki-widget');
        const widget = await waitFor(() => document.querySelector('valki-talki-widget'));
        await waitFor(() => widget.shadowRoot);
        const rootExists = !!document.getElementById('valki-root');
        const badge = widget.shadowRoot.querySelector('.badge');
        const badgeVisible = !!badge && badge.getClientRects().length > 0;
        if (badge) badge.click();
        await new Promise((resolve) => setTimeout(resolve, 150));
        const overlay = widget.shadowRoot.querySelector('.overlay');
        const overlayOpen = !!overlay && overlay.classList.contains('open');
        if (rootExists && badgeVisible && overlayOpen) {
          console.log('VALKI_SMOKE_OK');
        } else {
          console.warn('VALKI_SMOKE_FAIL', { rootExists, badgeVisible, overlayOpen });
        }
      };

      runSmoke().catch((error) => {
        console.error('VALKI_SMOKE_ERROR', error);
      });
    </script>
  </body>
</html>
